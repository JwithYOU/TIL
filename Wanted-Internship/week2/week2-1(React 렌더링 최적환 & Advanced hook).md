# 원티드 프리온보딩 프론트엔드 인턴쉽 2주차

## Week2-1

> ### 1.렌더링

### 1-1) 렌더링이란?

렌더링이란 화면에 특정한 요소를 그려내는 것을 의미합니다.  
브라우저에서 렌더링이란 DOM요소를 계산하고 그려내는 것입니다. HTML과 CSS를 통해서 만들어지고 계산된 DOM과 CSSOM은 결합되고, 위치를 계산하고, 최종적으로 브라우저에 그려냅니다. 그리고 브라우저에서 제공하는 DOM API를 Javascript를 통해 호출하면서 브라우저에 그려진 화면을 변화시킵니다.

하지만 Vanilla Javascript로만 DOM을 직접 수정하고(명령형) 또 이것을 최적화 하는 작업은 애플리케이션의 규묘가 커질수록 관리하기 힘들어집니다. 그래서 좀 더 나은 방식으로 애플리케이션에서 보여주고 싶은 핵심 UI를 "선언"하기만 하면 실제로 DOM을 조작해서 UI를 그려내고, 변화시키는 일은 라이브러리나 프레임워크가 대신 해주는 방식을 사용합니다(선언적 개발)

이러한 역할을 수행할 수 있는 React, Vue, Angular 등의 라이브러리, 프레임워크가 등장하게 되었습니다.

![20201 스택오버플로우 웹 프레임워크 사용 순위](https://github.com/JwithYOU/TIL/assets/83080505/5271a2e5-a703-4e21-b789-9ac18b7f4ed7)

2021년에 스택오버플로우에서 조사한 웹 프레임워크 사용 순위를 보면 React가 많이 선호되는 것을 볼 수 있습니다. 물론 현재는 다양한 프레임워크, 라이브러리가 출시됐기 때문에 미래에도 React 계속 선호될지는 알 수 없습니다.
그렇지만 이 글에서는 리액트를 기준으로 설명하겠습니다.

React 공식문서를 확인하면 첫번째 장점으로 "선언형"을 내세우고 있습니다. React가 선언형이기 때문에 실제 렌더링 과정은 React에서 대신 처리해줌으로서 개발자는 UI에 좀 더 집중할 수 있도록 도와줍니다. 하지만 때로 React 내부에서 처리해주는 렌더링을 최적화 해야 되는 상황이 발생하기도 합니다. 그래서 React 내부에서 렌더링이 언제 발생하는지, 어떤 과정을 거쳐서 이루어지는 알고 있어야 합니다.

### 1-2) 리액트에서 렌더링이 되는 시점

리액트에서는 state를 사용하는 이유는 UI와 상태(state)를 연동시키기 위해서입니다. 근본적으로 UI는 어떠한 데이터가 있고 그것을 보기 편한 형태로 표현한 것입니다. 리액트는 이를 이해하고 UI와 연동되어야 하고, 변할 여지가 있는 데이터들을 state라는 형태로 사용할 수 있게 하였습니다. 그리고 데이터가 변경되었을 때 UI가 그에 맞춰서 변화하기 위해서 state를 변경시키는 방법을 제한시키고(setState), 이 함수가 호출 될 때 마다 리렌더링이 되도록 하였습니다.

이런 이유로 state가 변경되면 리액트에서는 리렌더링이 발생합니다. 그리고 특정 컴포넌트의 state가 변경된다면 해당 컴포넌트와 컴포넌트 하위에 있는 모든 컴포넌트들도 리렌더링이 발생하게 됩니다.

state가 변경되면 해당 컴포넌트를 포함한 하위 컴포넌트들 모두 리렌더링이 발생한다는 사실을 인지하고 애플리케이션 설계에 들어가는 것이 리액트를 최적화하는 첫 걸음입니다.

### 1-3) 리액트의 렌더링 과정

앞서 설명했던 "렌더링"이 어떠한 과정으로 진행이 되는지 알아보도록 하겠습니다.  
앞서 언급했듯이 state가 변경이 되면 리렌더링이 발생합니다. state가 변경이 되고 최종적으로 브라우저의 UI에 반영되기까지 크게 4단계로 구분지을 수 있습니다.

1. 기존 컴포넌트의 UI를 재사용할지 확인합니다.
2. 함수 컴포넌트: 컴포넌트의 함수를 호출합니다. / Class 컴포넌트: `render` 메소드를 호출합니다.
3. 2단계의 결과를 통해서 새로운 VirtualDOM을 생성합니다.
4. 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제 변경된 부분만 DOM에 적용합니다.

먼저 이런 4단계를 거치는 이유와 VirtualDOM(가상돔)을 사용하는지 알아보겠습니다.  
브라우저는 HTML, CSS, Javascript를 다운받아 화면에 픽셀형태로 그려냅니다. 그리고 이 과정을  
CRP(Critical Rendering Path)라고 합니다. CRP는 아래의 과정을 수행합니다.

1. HTML을 파싱해서 DOM을 생성합니다.
2. CSS를 파싱해서 CSSOM을 생성합니다.
3. DOM과 CSSOM을 결합하여 Render Tree를 만듭니다.
4. Render Tree와 Viewport의 Width를 통해서 각 요소들의 위치와 크기를 계산합니다.(Layout)
5. 계산된 정보를 종합하여 Render Tree상의 요소들을 실제 Pixel로 그려냅니다.(Paint)

이후 DOM 또는 CSSOM이 수정될 때 마다 위의 과정을 반복합니다. 그런데 Layout과 Paint는 많은 계산을 필요로 합니다. 그래서 리액트는 CRP 횟수를 최적화하기 위해서 VirtualDOM을 사용합니다.

리액트 에서는 UI의 변화가 발생하면 변화에 필요한 조작을 DOM에 바로 적용하는 것이 아니라 이전의 VirtualDOM(DOM과 유사한 객체 형태)과 새로운 VirtualDOM을 비교해서 실제로 변화가 필요한 DOM 요소를 발견한 다음에 해당 DOM 요소들을 조작합니다.

이렇게 VirtualDOM을 활용해서 CRP의 빈도 수를 줄이는 것이 리액트의 최적화 하는 것입니다. 앞서 설명한 이전의 VirtualDOM 과 새로운 VirtualDOM의 끼리의 비교는 리액트 해주는 작업이므로 개발자 입장에서는 신경쓰지 않아도 되는 부분입니다.

그렇다면 리액트 개발자는 어느 부분에서 최적화를 진행할 수 있을까요?  
`1. 기존의 컴포넌트의 UI를 재사용할 지 확인한다.`  
`3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.`  
이 두분을 통해서 개발자는 최적화 작업을 할 수 있습니다.

좀 더 자세히 설명하면 `1. 기존의 컴포넌트의 UI를 재사용할 지 확인한다.` 의 경우에는 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다면 새롭게 컴포넌트 함수를 호출하지 않고 이전 결과값을 그대로 사용해서 최적화를 이룰 수 있습니다.  
또힌 `3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.` 의 경우는 컴포넌트 함수가 호출되면서 만들어지는 VirtualDOM의 형태를 비교적 차이가 적게 만들때 최적화가 됩니다. 예를 들어서 `div` 태그에서 `span` 태그로 변화 시키는 것이 아니라 `<div className="block" />`을 `<div className="inline" />`으로 변환시키는 것이 VirtualDOM을 비교했을 때 차이가 적은 형태로 만들어지는 것입니다.

> ### 2.React.memo

state 변경이 있으면 UI 변경이 있으니 리렌더링 해야하지만 굳이 왜 하위 컴포넌트까지 리렌더링 해야하나

리액트 메모 두번째 인자에 리턴값이 true이면 재사용을 하기 때문에 리렌더링이 되지 않는다

shallow compare(얕은 비교)는 한단계 키값만 비교한다 그래서 키값이 객체일 경우 그 안까지 검사하지 않는다

> ### useEffect & Context API

> ### 의존성 배열
