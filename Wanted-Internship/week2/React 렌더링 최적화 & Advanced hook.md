# 원티드 프리온보딩 프론트엔드 인턴쉽 2주차

> ## 1.렌더링

### 1-1) 렌더링이란?

렌더링이란 화면에 특정한 요소를 그려내는 것을 의미합니다.  
브라우저에서 렌더링이란 DOM요소를 계산하고 그려내는 것입니다. HTML과 CSS를 통해서 만들어지고 계산된 DOM과 CSSOM은 결합되고, 위치를 계산하고, 최종적으로 브라우저에 그려냅니다. 그리고 브라우저에서 제공하는 DOM API를 Javascript를 통해 호출하면서 브라우저에 그려진 화면을 변화시킵니다.

하지만 Vanilla Javascript로만 DOM을 직접 수정하고(명령형) 또 이것을 최적화 하는 작업은 애플리케이션의 규묘가 커질수록 관리하기 힘들어집니다. 그래서 좀 더 나은 방식으로 애플리케이션에서 보여주고 싶은 핵심 UI를 "선언"하기만 하면 실제로 DOM을 조작해서 UI를 그려내고, 변화시키는 일은 라이브러리나 프레임워크가 대신 해주는 방식을 사용합니다(선언적 개발)

이러한 역할을 수행할 수 있는 React, Vue, Angular 등의 라이브러리, 프레임워크가 등장하게 되었습니다.

![20201 스택오버플로우 웹 프레임워크 사용 순위](https://github.com/JwithYOU/TIL/assets/83080505/5271a2e5-a703-4e21-b789-9ac18b7f4ed7)

2021년에 스택오버플로우에서 조사한 웹 프레임워크 사용 순위를 보면 React가 많이 선호되는 것을 볼 수 있습니다. 물론 현재는 다양한 프레임워크, 라이브러리가 출시됐기 때문에 미래에도 React 계속 선호될지는 알 수 없습니다.
그렇지만 이 글에서는 리액트를 기준으로 설명하겠습니다.

React 공식문서를 확인하면 첫번째 장점으로 "선언형"을 내세우고 있습니다. React가 선언형이기 때문에 실제 렌더링 과정은 React에서 대신 처리해줌으로서 개발자는 UI에 좀 더 집중할 수 있도록 도와줍니다. 하지만 때로 React 내부에서 처리해주는 렌더링을 최적화 해야 되는 상황이 발생하기도 합니다. 그래서 React 내부에서 렌더링이 언제 발생하는지, 어떤 과정을 거쳐서 이루어지는 알고 있어야 합니다.

### 1-2) 리액트에서 렌더링이 되는 시점

리액트에서는 state를 사용하는 이유는 UI와 상태(state)를 연동시키기 위해서입니다. 근본적으로 UI는 어떠한 데이터가 있고 그것을 보기 편한 형태로 표현한 것입니다. 리액트는 이를 이해하고 UI와 연동되어야 하고, 변할 여지가 있는 데이터들을 state라는 형태로 사용할 수 있게 하였습니다. 그리고 데이터가 변경되었을 때 UI가 그에 맞춰서 변화하기 위해서 state를 변경시키는 방법을 제한시키고(setState), 이 함수가 호출 될 때 마다 리렌더링이 되도록 하였습니다.

이런 이유로 state가 변경되면 리액트에서는 리렌더링이 발생합니다. 그리고 특정 컴포넌트의 state가 변경된다면 해당 컴포넌트와 컴포넌트 하위에 있는 모든 컴포넌트들도 리렌더링이 발생하게 됩니다.

state가 변경되면 해당 컴포넌트를 포함한 하위 컴포넌트들 모두 리렌더링이 발생한다는 사실을 인지하고 애플리케이션 설계에 들어가는 것이 리액트를 최적화하는 첫 걸음입니다.

### 1-3) 리액트의 렌더링 과정

앞서 설명했던 "렌더링"이 어떠한 과정으로 진행이 되는지 알아보도록 하겠습니다.  
앞서 언급했듯이 state가 변경이 되면 리렌더링이 발생합니다. state가 변경이 되고 최종적으로 브라우저의 UI에 반영되기까지 크게 4단계로 구분지을 수 있습니다.

1. 기존 컴포넌트의 UI를 재사용할지 확인합니다.
2. 함수 컴포넌트: 컴포넌트의 함수를 호출합니다. / Class 컴포넌트: `render` 메소드를 호출합니다.
3. 2단계의 결과를 통해서 새로운 VirtualDOM을 생성합니다.
4. 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제 변경된 부분만 DOM에 적용합니다.

먼저 이런 4단계를 거치는 이유와 VirtualDOM(가상돔)을 사용하는지 알아보겠습니다.  
브라우저는 HTML, CSS, Javascript를 다운받아 화면에 픽셀형태로 그려냅니다. 그리고 이 과정을  
CRP(Critical Rendering Path)라고 합니다. CRP는 아래의 과정을 수행합니다.

1. HTML을 파싱해서 DOM을 생성합니다.
2. CSS를 파싱해서 CSSOM을 생성합니다.
3. DOM과 CSSOM을 결합하여 Render Tree를 만듭니다.
4. Render Tree와 Viewport의 Width를 통해서 각 요소들의 위치와 크기를 계산합니다.(Layout)
5. 계산된 정보를 종합하여 Render Tree상의 요소들을 실제 Pixel로 그려냅니다.(Paint)

이후 DOM 또는 CSSOM이 수정될 때 마다 위의 과정을 반복합니다. 그런데 Layout과 Paint는 많은 계산을 필요로 합니다. 그래서 리액트는 CRP 횟수를 최적화하기 위해서 VirtualDOM을 사용합니다.

리액트 에서는 UI의 변화가 발생하면 변화에 필요한 조작을 DOM에 바로 적용하는 것이 아니라 이전의 VirtualDOM(DOM과 유사한 객체 형태)과 새로운 VirtualDOM을 비교해서 실제로 변화가 필요한 DOM 요소를 발견한 다음에 해당 DOM 요소들을 조작합니다.

이렇게 VirtualDOM을 활용해서 CRP의 빈도 수를 줄이는 것이 리액트의 최적화 하는 것입니다. 앞서 설명한 이전의 VirtualDOM 과 새로운 VirtualDOM의 끼리의 비교는 리액트 해주는 작업이므로 개발자 입장에서는 신경쓰지 않아도 되는 부분입니다.

그렇다면 리액트 개발자는 어느 부분에서 최적화를 진행할 수 있을까요?  
`1. 기존의 컴포넌트의 UI를 재사용할 지 확인한다.`  
`3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.`  
이 두분을 통해서 개발자는 최적화 작업을 할 수 있습니다.

좀 더 자세히 설명하면 `1. 기존의 컴포넌트의 UI를 재사용할 지 확인한다.` 의 경우에는 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다면 새롭게 컴포넌트 함수를 호출하지 않고 이전 결과값을 그대로 사용해서 최적화를 이룰 수 있습니다.  
또힌 `3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.` 의 경우는 컴포넌트 함수가 호출되면서 만들어지는 VirtualDOM의 형태를 비교적 차이가 적게 만들때 최적화가 됩니다. 예를 들어서 `div` 태그에서 `span` 태그로 변화 시키는 것이 아니라 `<div className="block" />`을 `<div className="inline" />`으로 변환시키는 것이 VirtualDOM을 비교했을 때 차이가 적은 형태로 만들어지는 것입니다.

---

> ## 2.React.memo

앞에서 언급했듯이 state가 변경되면 해당 컴포넌트를 비롯한 모든 하위 컴포넌트들까지도 리렌더링이 됩니다. state가 변한 컴포넌트의 경우에는 UI가 변경되니 리렌더링이 되어야 하지만 하위 컴포넌트는 props가 변하지 않았다면 해당 컴포넌트의 UI가 변하지 않을 경우도 있습니다. 이런 경우에는 새롭게 다시 함수를 호출하는 것보다는 이전에 저장되어 있던 결과를 사용하는 것이 효율적입니다.

하지만 UI 변경이 있는지 렌더링 과정에 일일이 검사를 진행하는 것은 비효율적입니다. 그래서 리액트에서는 개발자가 리렌더링이 되어야할지 말아야할지를 표현할 수 있도록 `React.memo` 함수를 제공합니다. 이를 통해서 기존의 컴포넌트 UI 재사용 여부를 판단할 수 있습니다.

### 2-1) React.memo

```js
const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});
```

React.memo는 HOC(Higher Order Component)입니다.  
HOC는 컴포넌트를 인자로 받아서 컴포넌트를 리턴합니다.

React.memo로 감싸진 컴포넌트는 상위 컴포넌트가 리렌더링이 되어도 리렌더링이 되는 것이 아니라 이전 props와 다음 렌더링에 사용될 props를 비교해서 차이가 있을 경우에만 리렌더링을 합니다. 만약 차이가 없다면 리렌더링을 수행하지 않고 기존 렌더링 결과를 사용합니다. 이를 통해 컴포넌트가 불필요하게 리렌더링 되는 것을 막을 수 있습니다.

그렇다면 props 비교를 어떻게 할까요? React.memo는 props 비교를 기본적으로 `shallow compare`(얕은 비교) 방식으로 합니다. 만약 기본적인 비교 방식으로 사용하지 않고 직접 비교하는 로직을 사용하고 싶다면 변화를 판단하는 함수를 인자로 사용할 수 있도록 React.memo에서 설정할 수 있습니다.

```js
function MyComponet(props) {
  /* render using props */
}

function areEqual(prevProps, nextProps) {
  /*
    true일 경우에는 이전 결과를 재사용
    false일 경우에는 리렌더링
  */
}

export default React.memo(MyComponent, areEqual);
```

React.memo의 두번째 인자로 들어가는 함수의 리턴 값이 true면 이전 결과를 재사용하고, false이면 리렌더링을 합니다.

> 추가정보: shallow compare(얕은 비교)는 한단계 키값만 비교합니다 그래서 키값이 객체일 경우 그 안까지 검사하지 않습니다.

### 2-2) 자바스크립트 데이터 타입

React.memo가 props 객체간을 비교할 때 문제가 발생하지 않기 위해서는 자바스크립트의 데이터 타입, 그 중 기본형 타입과 참조형 타입의 차이에 대해서 알고 있어야 합니다.

자바스크립트의 데이터 타입 `string, number, boolean, null, undefined, object`가 있습니다. 이 타입들을 크게 두가지로 나눌 수 있는데 기본형 타입과 참조형 타입으로 구분됩니다.

기본형 타입은 원시형 타입이라고도 불립니다. 단어 자체에서도 알 수 있듯이 자바스크립트에서 지원하는 원시적이고 기본적인 형태의 데이터 타입이며 다른 데이터 없이는 스스로 온전히 존재할 수 있는 형태입니다. 원시형 타입의 예시는 `string, number, boolean, null, undefined, bigint, symbol` 이 있습니다.

참조형 타입은 객체형 타입이라고도 불립니다. 즉 원시형 타입을 제외한 `object` 가 참조형 타입이라고 할 수 있습니다. 참고로 자바스크립트에서는 array, function도 object의 한 종류입니다. 참조형 타입의 가장 큰 특징은 다른 데이터들을 모아서 만들어진 타입이라는 것입니다.

참조형 타입과 기본형 타입을 생각할 때 고려해야 할 가장 큰 특징은 "불변성" 입니다.

### 2-3) 불변성

불변성이란 값이 변하지 않는 것을 의미합니다. 기본적으로 원시형 타입은 모두 불변합니다. 예를 들어서

```js
let name = "Petter";

name = "John";
```

작성된 예시에서 변수 name은 "Petter"란 string이 "John"란 string으로 변경되는 방식이 아니라 "John"이라는 새로운 string을 만들고 name에 할당된 값 자체를 교체합니다.

이처럼 자바스크립트에서는 이미 만들어진 원시형 타입을 변경할 수는 없지만 참조형 타입은 가변이 가능합니다.

```js
const korea = { capital: "Seoul", food: "kimchi" };

korea.food = "bulgogi";
```

객체(참조형 타입)는 여러 타입들을 모아서 만들어진 형태입닏. 객체 안의 내용물을 언제든지, 어떤 형태로든 변경이 가능한데 이것을 "객체가 가변한다" 라고 합니다.  
가변성은 메모리를 절약하면서 객체를 유연하게 사용할 수 있지만 때때로 결과를 예상하기 힘들다는 점과 객체 간의 비교가 어렵다는 단점들이 있습니다.  
자바스크립트는 기본적으로 비교연산을 할 때 해당 데이터 메모리 주소를 가지고 일치 여부를 판단합니다. 원시형 타입의 경우 변경할 시 새로운 데이터가 만들어지고 교체되기 때문에 메모리 주소가 달라져서 비교연산 작업하기가 수월합니다.  
하지만 갹체의 경우에는 안의 내용이 어떻게 바뀌었는지와는 상관없이 해당 객체의 메모리 주소는 동일하기 때문에 실질적으로 내용이 변했는지는 판단하기 어렵습니다. 또한 내용물이 완전히 같은 두 객체를 비교할 때 각 객체가 가리키는 메모리 주소가 다르기 때문에 두 객체는 동일하지 않다는 결과가 나옵니다.

```js
const prev = { name: "prev" };
const next = prev;
next.name = "next";

prev === next; // true

const one = { hello: "world" };
const two = { hello: "world" };

one === two; // false
```

이런 동작으로 인해서 실제 객체의 내용이 같은지 확인하기 위해서는 두 객체 안의 모든 프로퍼티들을 순회하면서 비교해야 합니다. 만약 프로퍼티 중에서 객체가 존재한다면 연산의 복잡도는 기하급수적으로 늘어납니다.  
객체를 가변하게 사용하면 이렇게 객체 간의 비교는 힘들지만 한번 선언하고 메모리에 저장한 객체를 조금씩 변경하면서 활용할 수 있기 때문에 메모리 용량 측면에서는 효율적입니다.  
하지만 최근에는 객체를 선언하고 저장하는 메모리의 용량이 늘어났기 때문에 메모리에 효율성을 추구하기 보다는 객체 간의 비교의 편리함을 취하기 위해 객체를 불변하게 활요하는 방식이 최근에는 많이 사용되고 있습니다.  
객체를 불변하게 사용한다는 의미는 한번 만들어진 객체를 수정하지 않겠다는 것입니다. 내용을 수정해야할 경우에는 원시형 타입처럼 새로운 객체를 생성 후 교체하면 됩니다.

```js
const prev = { name: "prev", hello: "world" };
const next = { ...prev, name: "next" };

prev === next; // false
```

### 2-4) memo의 잘못된 활용

앞서 React.memo는 기본적으로 props의 변화를 이전 props와 새로운 props를 `shallow compare` 해서 판단한다고 했습니다. props를 shallow compare하는 의미는 다음과 같습니다.

props는 객체 형태로 표현됩니다. 그리고 props 객체는 매 렌더링마다 새롭게 생성되기 때문에 props 객체를 비교하는 것은 의미 없습니다.

그렇다면 비교해야 하는 것은 props 객체 안의 각 프로퍼티들입니다. 리액트는 props 객체 안의 각 프로퍼티들을 `Object.is(===)` 연산자를 사용해서 비교합니다. 이 중 하나라도 false가 나온다면 props가 변경되었다 판단하고 리렌더링을 수행합니다.

간단하게 React.memo를 잘못 사용한 예시를 가지고 설명해 보겠습니다.

```js
export default function App() {
  const [text, setText] = useState("");
  const [_, setState] = useState(1);

  const reRender = () => setState((prev) => prev + 1);
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={reRender}>re render</button>
      <MemoizedComponent name="memo O" value={text} reRender={reRender} />
    </>
  );
}

function ChildComponent({ name, value }) {
  console.log(`${name} rendered`);

  return (
    <h3>
      {name}: {value}
    </h3>
  );
}

const MemoizedComponent = React.memo(ChildComponent);
```

위 코드에서 text가 변경이되면 MemoizationComponent에 props가 변경이 되므로 리렌더링이됩니다. 하지만 reRender 함수가 호출이 되는 버튼을 클릭하면 text 변경이 없어도 리렌더링이됩니다. 그 이유는 reRender 함수가 state를 변경하기 때문에 상위 컴포넌트인 App 컴포넌트가 리렌더링이 됩니다. 앞서 언급했듯이 함수는 참조형 타입입니다. 이전 reRender 함수의 메모리 주소와 새로운 reRender 함수의 메모리 주소가 달라서 React.memo는 props에 담겨지는 reRender 함수가 같지않다 판단하고 리렌더링을 하게 됩니다.

---

> ## 3. Memoization

Memoization은 특정한 값을 저장해뒀다가, 이후에 해당 값이 필요할 때 새롭게 계산해서 사용하는게 아니라 저장해둔 값을 활용하는 테크닉을 의미합니다.

함수 컴포넌트는 근본적으로 함수입니다. 리액트에서는 매 렌더링마다 함수 컴포넌트를 다시 호출하는데 함수는 기본적으로 이전 호출과 새로운 호출간에 값을 공유할 수 없습니다. 만약 특정한 함수 호출 내에서 만들어진 변수를 다음 함수 호출때도 사용하고 싶으면 그 값을 외부의 특정한 공간에 저장하고 다음 호출 때 다시 꺼내와야 합니다.

직접 구현하는 작업이 꽤나 번거롭기 때문에 리액트에서는 보다 쉽게 함수 컴포넌트 값을 memoization 할 수 있게 hook을 제공하고 있습니다.

### 3-1) useMemo

useMemo는 리액트에서 값을 memoization 할 수 있도록 해줍니다.

```js
// useMemo(콜백함수, 의존성 배열)

const memoization = useMemo(() => computeExpensivevalue(a, b), [a, b]);
```

useMemo는 두 가지 인자를 받습니다. 첫 번째 인자는 콜백함수를 받고 두 번쩨 인자는 의존성 배열입니다. memoization은 사용할 때는 새로운 값을 만들어 사용해야하는 상황일 경우 이전 결과를 그대로 가져오지 않도록 주의해야합니다.

위 예시에 `a,b` 라는 두 가지 변수를 사용해서 memoization을 하기위한 값을 계산하고 있습니다. 만약 `a,b`의 값이 변했을 때 이전에 사용하던 값을 그대로 사용하면 의도와 달리 다른 결과를 초래하게 될 것입니다.

이런 경우를 방지하기 위해서 useMemo는 의존성 배열을 활용하고 있습니다. 의존성 배열에 있는 값이 이전 렌더링과 비교 했을 떄 다르다면 memoization 되어 있는 값을 활용하는게 아닌 새로운 값을 다시 계산해서 사용합니다.

### 3-2) useCallback

useCallback은 useMemo를 조금 더 편리하게 사용할 수 있도록하는 hook입니다.  
useMemo에서 일반적인 값들을 메모하기에는 편리하지만 함수를 메모하게 된다면 콜백함수에서 또 다른 함수를 리턴하는 형태가 되어버립니다. 동작상에는 아무런 문제가 없지만 직관적으로 봤을 떄 바로 코드를 이해하기 어려울 수 있습니다. 함수를 memoization하는 법을 useMemo와 useCallback을 사용한 예시를 보겠습니다.

```js
const memo = useMemo(() => () => console.log("useMemo"), []);

const callback = useCallback(() => console.log("useCallback"), []);
```

### 3-3) 언제 Memoization을 해야 할까?

`memoization` 기능만 봤을 때는 효율적이어서 무작정 사용하면 좋을거 같지만 명확한 목적없는 사용은 오히려 비효율적입니다.

mmemoization을 사용하기 전에 고민해 야봐야 할 부분이 있습니다.

**새로운 값을 만드는 것과 이전 값을 저장하고 memoization 함수를 호출해서 의존성을 비교하고 가져올지 말지 판단하는 것중에 어떤 것이 비용이 적게 들까?**

상황에 따라 다르겠지만 새로운 값을 만드는 과정이 복잡하다면 memoization을 사용하고 그렇지 않다면 새로 값을 만들어 사용하는게 효율적일 수 있습니다. 그리고 무분별한 memoization을 사용할 경우 컴퓨터 자원의 측면뿐만 아니라 코드의 복잡도 가 올라가기 때문에 개발적인 측면의 비용도 고려해야합니다.

memoization을 무조건 사용하는 것은 좋은게 아니기 때문에 필요하다고 판단될 때 사용하는 것이 좋습니다. 리액트에서 memoization의 필요성을 판단하는 요인 두 가지가 있습니다.

1. 새로운 값을 만드는 연산이 복잡하다.
2. 함수 컴포넌트의 이전 호출과 다음 호출 간 사용하는 값의 동일성을 보장하고 싶다.

1번의 경우에는 1000개의 요소를 가진 배열이 있다고 하면 값을 매번 생성하는 것보다 메모해서 사용하는 방식이 효율적일 것입니다. 2번의 경우에는 함수 컴포넌트의 호출 간 값들의 동일성을 보장하기 위해서 입니다. 동일성을 보장해야하는 이유는 `React.memo` 와 연동해서 사용하기 위함입니다.

앞서 memo의 잘못된 활용 예시에서 props로 전달되는 객체의 동일성이 보장되지 않아서 실제 객체의 내용은 같지만 `shallow compare`의 특성 때문에 다른 객체라고 판단되어서 매번 리렌더링이 되었습니다. 이런 경우에 객체의 동일성을 보장하기 위해서 memoization을 활용할 수 있습니다.

memoization된 객체는 새롭게 만들어진 것이 아니고 이전의 객체를 그대로 사용하는 것이 때문에 shallow compare에서도 동일함을 보장 받을 수 있습니다. 앞서 예시를 활용하면 props로 전돨되는 reRender 함수를 useCallback을 사용하면 됩니다.
