# 관심사 분리와 SRP, Custom Hook

> ## Clean Code

좋은 코드를 쓰는 것보다 나쁜 코드를 쓰지 않는 것이 중요합니다. 왜냐하면 코드는 소프트웨어 이루는 근간이기 때문입니다.  
하드웨어랑 소프트웨어에 문제가 있다고 가정해 봅시다. 상황에 따라 다르겠지만 하드웨어 문제가 생겼을 때 상대적으로 소프트웨어에 비해서 수리하기 힘듭니다. 그런데 만약 하드웨어와 소프트웨어 둘 다 문제가 많다면? 하드웨어는 리퍼 하듯이 부품을 싹 바꾸면 되는데 소프트웨어는 기존 코드가 좋지 않다면 어디서 부터 고쳐야 할지 어렵기 때문에 유지보수는 하드웨어보다 힘듭니다. 그래서 나쁜 코드를 짜지 않는 것이 중요합니다.

시간에 쫓겨서 좋은 코드를 짜거나 찾지 않는다면 어떻게 될까요?
시간을 아끼기 위해서 좋은 코드를 포기했는데 나중에는 더 많은 시간을 소비하게 됩니다. "프로젝트 완성이 더 급하니까 어쩔 수 없어", "출시하고나서 다시 고치자" 이런 마인드로 개발을 하는 것은 위험합니다. 다시 들여다 볼일이 없을 가능성이 크기 때문입니다. ~~다음 프로젝트 진행하셔야죠 ^^;~~

그렇다고 말씀드린 나쁜 코드가 "나중에 봤을 때 나쁜 코드"를 의미하는건 아닙니다. 그 때 당시에는 최선이었으나 시간이 흐르면서 레거시 취급을 받는 경우일 수도 있습니다. 이런 경우에는 마이그레이션 하거나 개편하는 작업이 가능합니다. 하지만 애초에 나쁜 코드는 이런 작업들을 하는게 거의 불가능합니다.

따라서 개발자는 좋은 코드를 작성해야합니다. 좋은 코드를 작성하기 위해서는 좋은 코드의 기준이 뭐고 그 방법이 무엇인지 끊임없이 고민해야 합니다.

---

> ## 관심사 분리

개발에는 관심사 분리(Seperation of Concerns)라는 용어가 있습니다.

이는 좋은 코드를 짜기 위한 가장 기본적인 원칙이며, 더 좋은 애플리케이션을 만들기 위한 여러 디자인 패턴, 기법, 아키텍쳐 등은 모두 SoC를 가장 기본적인 원칙으로 삼고 있습니다.

그렇다면 도대체 "관심사"가 뭐 길래 이렇게 까지 중요하다고 하는 걸까요?  
"관심사"를 간단히 설명하자면 `하나의 모듈이 수행하고자 하는 목적` 입니다, 여기서 모듈은 함수, 클래스 단위로 해석할 수 있습니다.

따라서 관심사 분리는 각 모듈들이 한번에 여러 관심사를 처리하는 것이 아닌 하나의 관심사만 처리하도록 분리하는 것입니다.

> ### 관심사를 분리하는 이유

그렇다면 왜 관심사를 분리해야 할까요? 하나의 모듈에서 여러 기능을 처리할 수 있다면 더 좋을거 같지 않나요?

관심사를 분리하면 하나의 모듈은 하나의 목적만 가지게 됩니다. 즉, 이 코드가 수정되는 이유는 딱 한가지만 존재한다는 의미입니다.

소프트웨어와 하드웨어를 나누는 극명한 기준이 무엇일까요? 하드웨어는 물리적으로 실체가 존재하고 소프트웨어는 코드로 구성된 무형의 상태입니다. 만약 하드웨어에 변형을 주려고 한다면 때로는 아예 새로 설계하고 제작하는게 나을 수도 있습니다. 하지만 상대적으로 소프트웨어는 수정이 쉽습니다. 변화에 유연하게 대응할 수 있다는게 소프트웨어의 장점인데 어디서부터 손대야 할지 모를 정도로 작성된 코드라면 일반 하드웨어와 별반 다를바가 없어집니다.

그래서 소프트웨어는 변화하는 것이 필연적이며, 좋은 소프트웨어 일수록 기존 기능 수정과 기능 확장을 잘할 수 있어야 합니다. 이를 흔히 `유지보수`라고 합니다.

본론으로 돌아와서 관심사 분리를 해야하는 이유는 하지 않을 때보다 신경 써야할 부분이 줄어든다는 것입니다. 만약 여러 모듈들이 여러 관심사를 동시에 다룬다면 특정분야에 대해서 수정을 할 때 관련된 모든 모듈을 수정해야할 것입니다.

관심사 분리는 프로그래밍에서 기본이 되는 원칙이며 이와 관련하여 비슷한 개념을 표현하는 여러 단어들과 프로그래밍 격언들이 생겨났습니다.

- 단일 책임 원칙(Single Responsibility Principle): 관심사의 분리와 유사한 개념이지만 관심사란 표현 대신에 책임이란 용어를 사용합니다. 각 모듈들은 책임(수행해야 하는 동작)을 가지고 있으며 각각 하나의 책임만을 가져야 한다는 원칙입니다.

- KISS(Keep It Simple, Stupid): 각 모듈들은 간단하고, 단순하게 만들라는 의미입니다. 여러 기능을 가져서 복잡하게 만들면 유지보수가 힘들기 때문에 하나의 기능만을 수행하도록 합니다. SoC, SRP 등의 원칙과 유사한 의미를 가지고 있습니다.

---

> ## Custom Hook

React V16.8에서 Hook이 발표되고 난 후 React에서 컴포넌트는 선언하는 방법의 선호도가 클래스에서 함수로 넘어왔습니다. 많은 사람들이 기존 클래스 컴포넌트 방식에서 함수 컴포넌트 방식으로 옮겨온 이유가 함수 컴포넌트의 문법이 더 단순하고, 교착 상태로 인한 버그가 발생하지 않는다는 점도 있겠지만 Cumstom Hook의 편리함과 유용성도 크게 한 몫을 했다고 생각합니다.

> ### 리액트의 관심사

그렇다면 리액트가 가진 관심사는 어떤 것들이 있을까요? 리액트는 UI를 구축하기 위한 라이브러입니다. 따라서 리액트가 가진 핵심적인 관심사는

1. UI
2. 로직(UI를 변경시키는 부분)

이 중 UI는 실제 코드상에서는 JSX라는 형태로 표현됩니다. 그리고 로직은 유저의 입력에만 반응하고, API를 호출하고, 스크린의 변화에 반응하는 등 여러 동작들을 통해서 UI에 영향을 미치는 행위라고 할 수 있습니다.

> ### 리액트에서 관심라를 분리하는 법: Presentational - Container

리액트를 활용하는 개발자들은 리액트의 관심사는 UI와 로직이란 것을 파악하고 이를 분리하기 위해서 여러 기법들을 연구하게 됩니다.

그 중 처음으로 유명해진 기법은 Presentional - Container 패턴입니다.  
Presentional - Container 기법은 컴포넌트를 크게 두 계층으로 분리하는 방법입니다.

Container는 로직들을 다루는 부분으로 UI에에는 관여하지 않고 오로 UI를 구성하고 변화하기 위한 로직에만 집중하느 컴포넌트입니다.

Presentional은 반대로 로직은 상관하지 않고 UI가 어떻게 구성되어야 하는지에만 집중하는 컴포넌트입니다.

이렇게 컴포넌트를 두 계층으로 나누어서 Presentional을 Container로 감싼 후, 필요한 정보들과 로직을 모두 props로 전달해주는 형태로 설계하는 방법이 Presentional - Container 패턴입니다.

이 패턴은 그 효용을 인정받아 Hook이 등장하기 전에는 관심사를 분리하는 패턴으로 사용되었습니다.

하지만 Hook이 등장하면서 Custom Hook이란 기법이 발명 되었고, 더 효율적으로 관심사를 분리할 수 있다고 판단이 되면서 Presentional - Container 패턴은 만힝 사용하지 않게 되었습니다.

> ### React에서 관심사를 분리하는 법: Custom Hook

커스텀 훅은 리액트가 기본적으로 제공해주는 훅들을(useState, useEffect) 이용해서 만든 함수입니다.

로직은 UI를 변경시키기 위하밍고, 함수형 컴포넌트에서 로직은 대부분 useState, useEffect 등의 Hook을 통해서 구현됩니다.

훅들을 통해서 편리한 점이 생겼지만 컴포넌트 내부에 많은 로직들이 들어가게 되면 컴포넌트가 복잡해지고 무엇보다 동일한 역할을 하는 로직들을 여러 컴포넌트에서 재사용하기 힘들다는 단점이 있습니다.

일반적으로 동일한 로직을 함수로 만들어서 사용하듯 리액트에서도 Hook들을 이용한 동일한 로직들을 별도의 함수로 만들어서 여러 컴포넌트에서 사용하기 시작하면서 커스텀 훅이라느 기법이 탄생하게 됩니다.

여기서 자주 실수하는 사항이 일반적인 utill 함수와 커스텀 훅을 혼동하는 것입니다. 커스텀 훅은 리액트에서 제공해주는 기본 훅(useState, useEffect)을 사용하거나 커스텀 훅(useNavigate)을 사용해서 만든 함수입니다.

커스텀 훅의 조건은 아래와 같습니다.

1. React의 Hook들을 호출하는 함수여야 한다.
2. 함수의 이름은 use로 시작해야 한다.

hook의 규칙

1. 순서를 지켜야한다
2. 제일 최상위 코드 블럭(스코프)에서 호출 되어야 한다.
3. 컴포넌트나 다른 커스텀 훅 내부에서만 호출 되어야 한다.(일반 함수 내에서 호출 X)

커스텀 훅이면 use를 잘 명시해야합니다. lint가 검사 할 때 훅인지 아닌지 여부를 use를 보고 판단하기 때문입니다. 그래서 기껏 커스텀 훅 만들고 use를 안 붙이면 사용했을 때 잘못된 부분이 있어도 lint가 캐치하지 못합니다.

---

> ## 질문

Q. 재사용이 안될 경우에도 커스텀 훅으로 사용해야하나요?  
A. 상황에 따라 다르겠지만 재사용 되지 않더라도 분리하는게 좋을 수 있습니다. 다른 관심사라면 분리하는게 권장되는 경우가 많습니다. 결국 추상화를 어느 정도까지 하는지가 중요합니다.

추상화란? 핵심적인 내용만 남기고 내부 동작을 숨기는 과정입니다. 너무 과한 추상화는 지양합니다. 그렇기 때문에 코드를 작성할 때 정답은 없습니다. 대신 작성한 근거는 있어야합니다.

Q. 인자로 setState 같은 걸 받으면 커스텀 훅인가요?  
A. 인자로 setState를 받는다고 커스텀 훅은 아닙니다. 인자가 setState를 받을 때 커스터 훅이면 아닐 때는 그냥 util 함수가 되어야하는 이상한 논리가 되기 때문입니다. 그래서 명확하게 훅을 사용해야만 커스텀 훅으로 분류가 됩니다.
